<?php
/**
 * ProductsV4Api
 * PHP version 5
 *
 * @category Class
 * @package  cbdesk\otto\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.69
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace cbdesk\otto\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use cbdesk\otto\Client\ApiException;
use cbdesk\otto\Client\Configuration;
use cbdesk\otto\Client\HeaderSelector;
use cbdesk\otto\Client\ObjectSerializer;

/**
 * ProductsV4Api Class Doc Comment
 *
 * @category Class
 * @package  cbdesk\otto\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProductsV4Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariations
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV4[] $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4
     */
    public function productsV4CreateOrUpdateProductVariations($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV4CreateOrUpdateProductVariationsWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4CreateOrUpdateProductVariationsWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4CreateOrUpdateProductVariationsRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsAsync
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4CreateOrUpdateProductVariationsAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4CreateOrUpdateProductVariationsAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4CreateOrUpdateProductVariationsRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4CreateOrUpdateProductVariations'
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4CreateOrUpdateProductVariationsRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v4/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4FailedByProcessId
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV4
     */
    public function productsV4FailedByProcessId($process_uuid)
    {
        list($response) = $this->productsV4FailedByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV4FailedByProcessIdWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4FailedByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4FailedByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4FailedByProcessIdAsync
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4FailedByProcessIdAsync($process_uuid)
    {
        return $this->productsV4FailedByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4FailedByProcessIdAsyncWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4FailedByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4FailedByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4FailedByProcessId'
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4FailedByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV4FailedByProcessId'
            );
        }

        $resourcePath = '/v4/products/update-tasks/{processUuid}/failed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetActiveStatus
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV4
     */
    public function productsV4GetActiveStatus($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetActiveStatusWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetActiveStatusWithHttpInfo
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetActiveStatusWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV4';
        $request = $this->productsV4GetActiveStatusRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetActiveStatusAsync
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetActiveStatusAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV4GetActiveStatusAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetActiveStatusAsyncWithHttpInfo
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetActiveStatusAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV4';
        $request = $this->productsV4GetActiveStatusRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetActiveStatus'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetActiveStatusRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v4/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetBrands
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page page (optional)
     * @param  int $limit limit (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\BrandListResponseProductsV4
     */
    public function productsV4GetBrands($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetBrandsWithHttpInfo($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetBrandsWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\BrandListResponseProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetBrandsWithHttpInfo($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\BrandListResponseProductsV4';
        $request = $this->productsV4GetBrandsRequest($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\BrandListResponseProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetBrandsAsync
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetBrandsAsync($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        return $this->productsV4GetBrandsAsyncWithHttpInfo($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetBrandsAsyncWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetBrandsAsyncWithHttpInfo($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\BrandListResponseProductsV4';
        $request = $this->productsV4GetBrandsRequest($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetBrands'
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetBrandsRequest($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {

        $resourcePath = '/v4/products/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }
        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }
        // header params
        if ($if_modified_since !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($if_modified_since);
        }
        // header params
        if ($if_unmodified_since !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($if_unmodified_since);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetCategoryGroups
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\CategoryGroupsProductsV4
     */
    public function productsV4GetCategoryGroups($page = null, $limit = null, $category = null)
    {
        list($response) = $this->productsV4GetCategoryGroupsWithHttpInfo($page, $limit, $category);
        return $response;
    }

    /**
     * Operation productsV4GetCategoryGroupsWithHttpInfo
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\CategoryGroupsProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetCategoryGroupsWithHttpInfo($page = null, $limit = null, $category = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\CategoryGroupsProductsV4';
        $request = $this->productsV4GetCategoryGroupsRequest($page, $limit, $category);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\CategoryGroupsProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetCategoryGroupsAsync
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetCategoryGroupsAsync($page = null, $limit = null, $category = null)
    {
        return $this->productsV4GetCategoryGroupsAsyncWithHttpInfo($page, $limit, $category)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetCategoryGroupsAsyncWithHttpInfo
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetCategoryGroupsAsyncWithHttpInfo($page = null, $limit = null, $category = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\CategoryGroupsProductsV4';
        $request = $this->productsV4GetCategoryGroupsRequest($page, $limit, $category);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetCategoryGroups'
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetCategoryGroupsRequest($page = null, $limit = null, $category = null)
    {

        $resourcePath = '/v4/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetContentChanges
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4
     */
    public function productsV4GetContentChanges($sku, $from_date = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetContentChangesWithHttpInfo($sku, $from_date, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetContentChangesWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetContentChangesWithHttpInfo($sku, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChangesRequest($sku, $from_date, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetContentChangesAsync
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChangesAsync($sku, $from_date = null, $page = null, $limit = null)
    {
        return $this->productsV4GetContentChangesAsyncWithHttpInfo($sku, $from_date, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetContentChangesAsyncWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChangesAsyncWithHttpInfo($sku, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChangesRequest($sku, $from_date, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetContentChanges'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetContentChangesRequest($sku, $from_date = null, $page = null, $limit = null)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetContentChanges'
            );
        }

        $resourcePath = '/v4/products/{sku}/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }

        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetContentChanges2
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4
     */
    public function productsV4GetContentChanges2($sku = null, $from_date = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetContentChanges2WithHttpInfo($sku, $from_date, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetContentChanges2WithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetContentChanges2WithHttpInfo($sku = null, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChanges2Request($sku, $from_date, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetContentChanges2Async
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChanges2Async($sku = null, $from_date = null, $page = null, $limit = null)
    {
        return $this->productsV4GetContentChanges2AsyncWithHttpInfo($sku, $from_date, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetContentChanges2AsyncWithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetContentChanges2AsyncWithHttpInfo($sku = null, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV4';
        $request = $this->productsV4GetContentChanges2Request($sku, $from_date, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetContentChanges2'
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetContentChanges2Request($sku = null, $from_date = null, $page = null, $limit = null)
    {

        $resourcePath = '/v4/products/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($sku)) {
            $sku = ObjectSerializer::serializeCollection($sku, 'multi', true);
        }
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetMarketPlaceStatus
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\MarketPlaceStatusProductsV4
     */
    public function productsV4GetMarketPlaceStatus($sku)
    {
        list($response) = $this->productsV4GetMarketPlaceStatusWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV4GetMarketPlaceStatusWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\MarketPlaceStatusProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetMarketPlaceStatusWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetMarketPlaceStatusAsync
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusAsync($sku)
    {
        return $this->productsV4GetMarketPlaceStatusAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusAsyncWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetMarketPlaceStatus'
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetMarketPlaceStatusRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetMarketPlaceStatus'
            );
        }

        $resourcePath = '/v4/products/{sku}/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusList
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV4
     */
    public function productsV4GetMarketPlaceStatusList($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        list($response) = $this->productsV4GetMarketPlaceStatusListWithHttpInfo($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);
        return $response;
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetMarketPlaceStatusListWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusListRequest($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListAsync
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusListAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        return $this->productsV4GetMarketPlaceStatusListAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetMarketPlaceStatusListAsyncWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetMarketPlaceStatusListAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV4';
        $request = $this->productsV4GetMarketPlaceStatusListRequest($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetMarketPlaceStatusList'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetMarketPlaceStatusListRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {

        $resourcePath = '/v4/products/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if (is_array($market_place_status)) {
            $market_place_status = ObjectSerializer::serializeCollection($market_place_status, 'multi', true);
        }
        if ($market_place_status !== null) {
            $queryParams['marketPlaceStatus'] = ObjectSerializer::toQueryValue($market_place_status, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sort-order'] = ObjectSerializer::toQueryValue($sort_order, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetPartnerProducts
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductVariationApiResultProductsV4
     */
    public function productsV4GetPartnerProducts($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetPartnerProductsWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetPartnerProductsWithHttpInfo
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductVariationApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetPartnerProductsWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV4';
        $request = $this->productsV4GetPartnerProductsRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetPartnerProductsAsync
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetPartnerProductsAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV4GetPartnerProductsAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetPartnerProductsAsyncWithHttpInfo
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetPartnerProductsAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV4';
        $request = $this->productsV4GetPartnerProductsRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetPartnerProducts'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetPartnerProductsRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v4/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariation
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductVariationProductsV4
     */
    public function productsV4GetProductVariation($sku)
    {
        list($response) = $this->productsV4GetProductVariationWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductVariationProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationProductsV4';
        $request = $this->productsV4GetProductVariationRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductVariationProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationAsync
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationAsync($sku)
    {
        return $this->productsV4GetProductVariationAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationAsyncWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationProductsV4';
        $request = $this->productsV4GetProductVariationRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariation'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetProductVariationRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetProductVariation'
            );
        }

        $resourcePath = '/v4/products/{sku}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariationPrice
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\SkuPricingProductsV4
     */
    public function productsV4GetProductVariationPrice($sku)
    {
        list($response) = $this->productsV4GetProductVariationPriceWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationPriceWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\SkuPricingProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationPriceWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\SkuPricingProductsV4';
        $request = $this->productsV4GetProductVariationPriceRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\SkuPricingProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationPriceAsync
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPriceAsync($sku)
    {
        return $this->productsV4GetProductVariationPriceAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationPriceAsyncWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPriceAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\SkuPricingProductsV4';
        $request = $this->productsV4GetProductVariationPriceRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariationPrice'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetProductVariationPriceRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetProductVariationPrice'
            );
        }

        $resourcePath = '/v4/products/{sku}/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetProductVariationPrices
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\PriceApiResultProductsV4
     */
    public function productsV4GetProductVariationPrices($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV4GetProductVariationPricesWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV4GetProductVariationPricesWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\PriceApiResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetProductVariationPricesWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\PriceApiResultProductsV4';
        $request = $this->productsV4GetProductVariationPricesRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\PriceApiResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetProductVariationPricesAsync
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPricesAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV4GetProductVariationPricesAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetProductVariationPricesAsyncWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetProductVariationPricesAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\PriceApiResultProductsV4';
        $request = $this->productsV4GetProductVariationPricesRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetProductVariationPrices'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetProductVariationPricesRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v4/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4GetVariationActiveStatus
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ActiveStatusProductsV4
     */
    public function productsV4GetVariationActiveStatus($sku)
    {
        list($response) = $this->productsV4GetVariationActiveStatusWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV4GetVariationActiveStatusWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ActiveStatusProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4GetVariationActiveStatusWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusProductsV4';
        $request = $this->productsV4GetVariationActiveStatusRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ActiveStatusProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4GetVariationActiveStatusAsync
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetVariationActiveStatusAsync($sku)
    {
        return $this->productsV4GetVariationActiveStatusAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4GetVariationActiveStatusAsyncWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4GetVariationActiveStatusAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusProductsV4';
        $request = $this->productsV4GetVariationActiveStatusRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4GetVariationActiveStatus'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4GetVariationActiveStatusRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV4GetVariationActiveStatus'
            );
        }

        $resourcePath = '/v4/products/{sku}/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4ProgressByProcessId
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4
     */
    public function productsV4ProgressByProcessId($process_uuid)
    {
        list($response) = $this->productsV4ProgressByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV4ProgressByProcessIdWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4ProgressByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4ProgressByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4ProgressByProcessIdAsync
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4ProgressByProcessIdAsync($process_uuid)
    {
        return $this->productsV4ProgressByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4ProgressByProcessIdAsyncWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4ProgressByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4ProgressByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4ProgressByProcessId'
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4ProgressByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV4ProgressByProcessId'
            );
        }

        $resourcePath = '/v4/products/update-tasks/{processUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4SucceededByProcessId
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV4
     */
    public function productsV4SucceededByProcessId($process_uuid)
    {
        list($response) = $this->productsV4SucceededByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV4SucceededByProcessIdWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4SucceededByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4SucceededByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4SucceededByProcessIdAsync
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4SucceededByProcessIdAsync($process_uuid)
    {
        return $this->productsV4SucceededByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4SucceededByProcessIdAsyncWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4SucceededByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4SucceededByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4SucceededByProcessId'
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4SucceededByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV4SucceededByProcessId'
            );
        }

        $resourcePath = '/v4/products/update-tasks/{processUuid}/succeeded';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UnchangedByProcessId
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV4
     */
    public function productsV4UnchangedByProcessId($process_uuid)
    {
        list($response) = $this->productsV4UnchangedByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV4UnchangedByProcessIdWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UnchangedByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4UnchangedByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UnchangedByProcessIdAsync
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UnchangedByProcessIdAsync($process_uuid)
    {
        return $this->productsV4UnchangedByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UnchangedByProcessIdAsyncWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UnchangedByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV4';
        $request = $this->productsV4UnchangedByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UnchangedByProcessId'
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4UnchangedByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV4UnchangedByProcessId'
            );
        }

        $resourcePath = '/v4/products/update-tasks/{processUuid}/unchanged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UpdateActiveStatus
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV4 $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4
     */
    public function productsV4UpdateActiveStatus($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV4UpdateActiveStatusWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV4UpdateActiveStatusWithHttpInfo
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV4 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UpdateActiveStatusWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateActiveStatusRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UpdateActiveStatusAsync
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV4 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateActiveStatusAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV4UpdateActiveStatusAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UpdateActiveStatusAsyncWithHttpInfo
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV4 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateActiveStatusAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateActiveStatusRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UpdateActiveStatus'
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV4 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4UpdateActiveStatusRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v4/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV4UpdateProductVariationPrices
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV4[] $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4
     */
    public function productsV4UpdateProductVariationPrices($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV4UpdateProductVariationPricesWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV4UpdateProductVariationPricesWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV4UpdateProductVariationPricesWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateProductVariationPricesRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV4UpdateProductVariationPricesAsync
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateProductVariationPricesAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV4UpdateProductVariationPricesAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV4UpdateProductVariationPricesAsyncWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV4UpdateProductVariationPricesAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV4';
        $request = $this->productsV4UpdateProductVariationPricesRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV4UpdateProductVariationPrices'
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV4[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV4UpdateProductVariationPricesRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v4/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
