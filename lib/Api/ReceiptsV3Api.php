<?php
/**
 * ReceiptsV3Api
 * PHP version 5
 *
 * @category Class
 * @package  cbdesk\otto\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.69
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace cbdesk\otto\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use cbdesk\otto\Client\ApiException;
use cbdesk\otto\Client\Configuration;
use cbdesk\otto\Client\HeaderSelector;
use cbdesk\otto\Client\ObjectSerializer;

/**
 * ReceiptsV3Api Class Doc Comment
 *
 * @category Class
 * @package  cbdesk\otto\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReceiptsV3Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function receiptsV3GetReceiptPdfUsingGET3($receipt_number)
    {
        $this->receiptsV3GetReceiptPdfUsingGET3WithHttpInfo($receipt_number);
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3WithHttpInfo
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptPdfUsingGET3WithHttpInfo($receipt_number)
    {
        $returnType = '';
        $request = $this->receiptsV3GetReceiptPdfUsingGET3Request($receipt_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3Async
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptPdfUsingGET3Async($receipt_number)
    {
        return $this->receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo($receipt_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo
     *
     * Get the PDF document of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptPdfUsingGET3AsyncWithHttpInfo($receipt_number)
    {
        $returnType = '';
        $request = $this->receiptsV3GetReceiptPdfUsingGET3Request($receipt_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptPdfUsingGET3'
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function receiptsV3GetReceiptPdfUsingGET3Request($receipt_number)
    {
        // verify the required parameter 'receipt_number' is set
        if ($receipt_number === null || (is_array($receipt_number) && count($receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_number when calling receiptsV3GetReceiptPdfUsingGET3'
            );
        }

        $resourcePath = '/v3/receipts/{receiptNumber}.pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ReceiptReceiptsV3
     */
    public function receiptsV3GetReceiptUsingGET5($receipt_number)
    {
        list($response) = $this->receiptsV3GetReceiptUsingGET5WithHttpInfo($receipt_number);
        return $response;
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5WithHttpInfo
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ReceiptReceiptsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptUsingGET5WithHttpInfo($receipt_number)
    {
        $returnType = '\cbdesk\otto\Client\Model\ReceiptReceiptsV3';
        $request = $this->receiptsV3GetReceiptUsingGET5Request($receipt_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ReceiptReceiptsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5Async
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptUsingGET5Async($receipt_number)
    {
        return $this->receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo($receipt_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo
     *
     * Get the JSON object of a specific receipt
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptUsingGET5AsyncWithHttpInfo($receipt_number)
    {
        $returnType = '\cbdesk\otto\Client\Model\ReceiptReceiptsV3';
        $request = $this->receiptsV3GetReceiptUsingGET5Request($receipt_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptUsingGET5'
     *
     * @param  string $receipt_number ReceiptNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function receiptsV3GetReceiptUsingGET5Request($receipt_number)
    {
        // verify the required parameter 'receipt_number' is set
        if ($receipt_number === null || (is_array($receipt_number) && count($receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_number when calling receiptsV3GetReceiptUsingGET5'
            );
        }

        $resourcePath = '/v3/receipts/{receiptNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5
     *
     * Get receipts as list of JSON objects
     *
     * @param  int $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#x27;next&#x27; parameter (optional, default to 1)
     * @param  string[] $receipt_types Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string $sales_order_id Search for receipts filtered by sales order Id (optional)
     * @param  string $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#x27;limit&#x27;  Note: Only the cursor string is required - not the whole link (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ReceiptsListReceiptsV3
     */
    public function receiptsV3GetReceiptsUsingGET5($limit = '128', $page = '1', $receipt_types = null, $from = null, $to = null, $sales_order_id = null, $next = null)
    {
        list($response) = $this->receiptsV3GetReceiptsUsingGET5WithHttpInfo($limit, $page, $receipt_types, $from, $to, $sales_order_id, $next);
        return $response;
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5WithHttpInfo
     *
     * Get receipts as list of JSON objects
     *
     * @param  int $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#x27;next&#x27; parameter (optional, default to 1)
     * @param  string[] $receipt_types Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string $sales_order_id Search for receipts filtered by sales order Id (optional)
     * @param  string $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#x27;limit&#x27;  Note: Only the cursor string is required - not the whole link (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ReceiptsListReceiptsV3, HTTP status code, HTTP response headers (array of strings)
     */
    public function receiptsV3GetReceiptsUsingGET5WithHttpInfo($limit = '128', $page = '1', $receipt_types = null, $from = null, $to = null, $sales_order_id = null, $next = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ReceiptsListReceiptsV3';
        $request = $this->receiptsV3GetReceiptsUsingGET5Request($limit, $page, $receipt_types, $from, $to, $sales_order_id, $next);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ReceiptsListReceiptsV3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5Async
     *
     * Get receipts as list of JSON objects
     *
     * @param  int $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#x27;next&#x27; parameter (optional, default to 1)
     * @param  string[] $receipt_types Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string $sales_order_id Search for receipts filtered by sales order Id (optional)
     * @param  string $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#x27;limit&#x27;  Note: Only the cursor string is required - not the whole link (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptsUsingGET5Async($limit = '128', $page = '1', $receipt_types = null, $from = null, $to = null, $sales_order_id = null, $next = null)
    {
        return $this->receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo($limit, $page, $receipt_types, $from, $to, $sales_order_id, $next)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo
     *
     * Get receipts as list of JSON objects
     *
     * @param  int $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#x27;next&#x27; parameter (optional, default to 1)
     * @param  string[] $receipt_types Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string $sales_order_id Search for receipts filtered by sales order Id (optional)
     * @param  string $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#x27;limit&#x27;  Note: Only the cursor string is required - not the whole link (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function receiptsV3GetReceiptsUsingGET5AsyncWithHttpInfo($limit = '128', $page = '1', $receipt_types = null, $from = null, $to = null, $sales_order_id = null, $next = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ReceiptsListReceiptsV3';
        $request = $this->receiptsV3GetReceiptsUsingGET5Request($limit, $page, $receipt_types, $from, $to, $sales_order_id, $next);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'receiptsV3GetReceiptsUsingGET5'
     *
     * @param  int $limit Page size to limit the number of receipts returned in the response (optional, default to 128)
     * @param  int $page Page number to fetch. This parameter is required to fetch data for specific page number. &lt;/br&gt;This field is deprecated, please use &#x27;next&#x27; parameter (optional, default to 1)
     * @param  string[] $receipt_types Search for receipts filtered by multiple receipt types.  &lt;/br&gt;PURCHASE - A purchase receipt (also known as an invoice) records the prices charged to the customer at the time of sale. The receipt contains information per order, partner and shipment. It is generated when items are shipped to the customer, so there may be more than one receipt per order. Shipping costs are charged only once per partner and per order, and are billed with first purchase receipt of this partner order. Surcharges imposed by payment provider on the customer for using special payment conditions are not included in the OTTO Market receipts.  &lt;/br&gt;REFUND - We distinguish between different types of reimbursement documents. A refund receipt documents a credit note issued to a customer for a refund. This document is currently created when returns are accepted.  In very rare cases, refund receipts may also be created during the cancellation process to reimburse shipping costs for full returns.  Previous partial refunds will be taken into account.  &lt;/br&gt; PARTIAL_REFUND -  We distinguish different types of reimbursement documents. A partial refund receipt documents a credit note issued to a customer without return.  As a partner, you might offer a customer a partial refund if there is a legitimate complaint to avoid a return.  &lt;/br&gt;If no receiptType is provided, receipts  of all existing receiptTypes will be returned.  &lt;b&gt;Please for your own interest, hand over all receipt types you are interested in using the list parameter receiptTypes, so that OTTO Market could add new receipt types without side effects for your own processes. Using this option you can decide by your own when to incorporate new receipt types in your own processes.   Please do not use the possibility of calls without specifying the receiptTypes anymore.&lt;/b&gt; (optional)
     * @param  \DateTime $from Only receipts with creation date newer or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  \DateTime $to Only receipts with creation date older or equal than the date specified (yyy-mm-dd in UTC) will be returned. (optional)
     * @param  string $sales_order_id Search for receipts filtered by sales order Id (optional)
     * @param  string $next Cursor for paging requests. If a next cursor is provided, the only other request parameter being considered is &#x27;limit&#x27;  Note: Only the cursor string is required - not the whole link (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function receiptsV3GetReceiptsUsingGET5Request($limit = '128', $page = '1', $receipt_types = null, $from = null, $to = null, $sales_order_id = null, $next = null)
    {

        $resourcePath = '/v3/receipts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if (is_array($receipt_types)) {
            $receipt_types = ObjectSerializer::serializeCollection($receipt_types, 'multi', true);
        }
        if ($receipt_types !== null) {
            $queryParams['receiptTypes'] = ObjectSerializer::toQueryValue($receipt_types, null);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from, 'date');
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = ObjectSerializer::toQueryValue($to, 'date');
        }
        // query params
        if ($sales_order_id !== null) {
            $queryParams['salesOrderId'] = ObjectSerializer::toQueryValue($sales_order_id, null);
        }
        // query params
        if ($next !== null) {
            $queryParams['next'] = ObjectSerializer::toQueryValue($next, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
