<?php
/**
 * ProductsV5Api
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * OTTO Market API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.69
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace cbdesk\otto\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use cbdesk\otto\Client\ApiException;
use cbdesk\otto\Client\Configuration;
use cbdesk\otto\Client\HeaderSelector;
use cbdesk\otto\Client\ObjectSerializer;

/**
 * ProductsV5Api Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProductsV5Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsV5CreateOrUpdateProductVariations
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV5[] $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5
     */
    public function productsV5CreateOrUpdateProductVariations($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV5CreateOrUpdateProductVariationsWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV5CreateOrUpdateProductVariationsWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5CreateOrUpdateProductVariationsWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5CreateOrUpdateProductVariationsRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5CreateOrUpdateProductVariationsAsync
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5CreateOrUpdateProductVariationsAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV5CreateOrUpdateProductVariationsAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5CreateOrUpdateProductVariationsAsyncWithHttpInfo
     *
     * Create or update product variations
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5CreateOrUpdateProductVariationsAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5CreateOrUpdateProductVariationsRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5CreateOrUpdateProductVariations'
     *
     * @param  \cbdesk\otto\Client\Model\ProductVariationProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5CreateOrUpdateProductVariationsRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v5/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5FailedByProcessId
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV5
     */
    public function productsV5FailedByProcessId($process_uuid)
    {
        list($response) = $this->productsV5FailedByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV5FailedByProcessIdWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5FailedByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5FailedByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5FailedByProcessIdAsync
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5FailedByProcessIdAsync($process_uuid)
    {
        return $this->productsV5FailedByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5FailedByProcessIdAsyncWithHttpInfo
     *
     * List failed products of a product data delivery
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5FailedByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5FailedByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5FailedByProcessId'
     *
     * @param  string $process_uuid search for the failed products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5FailedByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV5FailedByProcessId'
            );
        }

        $resourcePath = '/v5/products/update-tasks/{processUuid}/failed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetActiveStatus
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV5
     */
    public function productsV5GetActiveStatus($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetActiveStatusWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetActiveStatusWithHttpInfo
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetActiveStatusWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV5';
        $request = $this->productsV5GetActiveStatusRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetActiveStatusAsync
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetActiveStatusAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV5GetActiveStatusAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetActiveStatusAsyncWithHttpInfo
     *
     * Read active status
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetActiveStatusAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusListResponseProductsV5';
        $request = $this->productsV5GetActiveStatusRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetActiveStatus'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brand ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of active status values per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetActiveStatusRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v5/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetBrands
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page page (optional)
     * @param  int $limit limit (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\BrandListResponseProductsV5
     */
    public function productsV5GetBrands($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetBrandsWithHttpInfo($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetBrandsWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\BrandListResponseProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetBrandsWithHttpInfo($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\BrandListResponseProductsV5';
        $request = $this->productsV5GetBrandsRequest($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\BrandListResponseProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetBrandsAsync
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetBrandsAsync($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        return $this->productsV5GetBrandsAsyncWithHttpInfo($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetBrandsAsyncWithHttpInfo
     *
     * List of allowed brands
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetBrandsAsyncWithHttpInfo($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\BrandListResponseProductsV5';
        $request = $this->productsV5GetBrandsRequest($if_match, $if_none_match, $if_modified_since, $if_unmodified_since, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetBrands'
     *
     * @param  string $if_match The RFC7232 If-Match header field in a request requires the server to only operate on the resource that matches at least one of the provided entity-tags. This allows clients express a precondition that prevent the method from being applied if there have been any changes to the resource (see [RFC 7232 Section 3.1](https://tools.ietf.org/html/rfc7232#section-3.1). (optional)
     * @param  string $if_none_match The RFC7232 If-None-Match header field in a request requires the server to only operate on the resource if it does not match any of the provided entity-tags. If the provided entity-tag is &#x60;*&#x60;, it is required that the resource does not exist at all (see [RFC 7232 Section 3.2](https://tools.ietf.org/html/rfc7232#section-3.2) (optional)
     * @param  string $if_modified_since The RFC7232 If-Modified-Since header field makes a GET or HEAD request method conditional on the selected representation&#x27;s modification date being more recent than the date provided in the field-value. Transfer of the selected representation&#x27;s data is avoided if that data has not changed. (optional)
     * @param  string $if_unmodified_since The RFC7232 If-Unmodified-Since header field makes the request method conditional on the selected representation&#x27;s last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation. (optional)
     * @param  int $page (optional)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetBrandsRequest($if_match = null, $if_none_match = null, $if_modified_since = null, $if_unmodified_since = null, $page = null, $limit = null)
    {

        $resourcePath = '/v5/products/brands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }
        // header params
        if ($if_none_match !== null) {
            $headerParams['If-None-Match'] = ObjectSerializer::toHeaderValue($if_none_match);
        }
        // header params
        if ($if_modified_since !== null) {
            $headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue($if_modified_since);
        }
        // header params
        if ($if_unmodified_since !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($if_unmodified_since);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetCategoryGroups
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\CategoryGroupsProductsV5
     */
    public function productsV5GetCategoryGroups($page = null, $limit = null, $category = null)
    {
        list($response) = $this->productsV5GetCategoryGroupsWithHttpInfo($page, $limit, $category);
        return $response;
    }

    /**
     * Operation productsV5GetCategoryGroupsWithHttpInfo
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\CategoryGroupsProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetCategoryGroupsWithHttpInfo($page = null, $limit = null, $category = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\CategoryGroupsProductsV5';
        $request = $this->productsV5GetCategoryGroupsRequest($page, $limit, $category);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\CategoryGroupsProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetCategoryGroupsAsync
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetCategoryGroupsAsync($page = null, $limit = null, $category = null)
    {
        return $this->productsV5GetCategoryGroupsAsyncWithHttpInfo($page, $limit, $category)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetCategoryGroupsAsyncWithHttpInfo
     *
     * Read product categories
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetCategoryGroupsAsyncWithHttpInfo($page = null, $limit = null, $category = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\CategoryGroupsProductsV5';
        $request = $this->productsV5GetCategoryGroupsRequest($page, $limit, $category);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetCategoryGroups'
     *
     * @param  int $page the number (starting with 0) of the page, that should be delivered. (optional)
     * @param  int $limit proposed limit for the number of product categories per response page  (at most 2000) (optional)
     * @param  string $category read a single category (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetCategoryGroupsRequest($page = null, $limit = null, $category = null)
    {

        $resourcePath = '/v5/products/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetContentChanges
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5
     */
    public function productsV5GetContentChanges($sku, $from_date = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetContentChangesWithHttpInfo($sku, $from_date, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetContentChangesWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetContentChangesWithHttpInfo($sku, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5';
        $request = $this->productsV5GetContentChangesRequest($sku, $from_date, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetContentChangesAsync
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetContentChangesAsync($sku, $from_date = null, $page = null, $limit = null)
    {
        return $this->productsV5GetContentChangesAsyncWithHttpInfo($sku, $from_date, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetContentChangesAsyncWithHttpInfo
     *
     * Read content changes for a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetContentChangesAsyncWithHttpInfo($sku, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5';
        $request = $this->productsV5GetContentChangesRequest($sku, $from_date, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetContentChanges'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     * @param  \DateTime $from_date search for content changes from this ISO8601 date on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of entries per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetContentChangesRequest($sku, $from_date = null, $page = null, $limit = null)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5GetContentChanges'
            );
        }

        $resourcePath = '/v5/products/{sku}/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }

        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetContentChanges2
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5
     */
    public function productsV5GetContentChanges2($sku = null, $from_date = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetContentChanges2WithHttpInfo($sku, $from_date, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetContentChanges2WithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetContentChanges2WithHttpInfo($sku = null, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5';
        $request = $this->productsV5GetContentChanges2Request($sku, $from_date, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetContentChanges2Async
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetContentChanges2Async($sku = null, $from_date = null, $page = null, $limit = null)
    {
        return $this->productsV5GetContentChanges2AsyncWithHttpInfo($sku, $from_date, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetContentChanges2AsyncWithHttpInfo
     *
     * Read content changes within time period
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetContentChanges2AsyncWithHttpInfo($sku = null, $from_date = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ContentChangesApiResultProductsV5';
        $request = $this->productsV5GetContentChanges2Request($sku, $from_date, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetContentChanges2'
     *
     * @param  string[] $sku search for product variations by their sku value. Use this to query for multiple variations or if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. You may separate multiple sku values by comma or state each one with a &amp;sku&#x3D; in front of the value. Please note that if you like to query for a single variation whose value contains a comma you have to add one empty &amp;sku&#x3D; at the end of the query string or use the other endpoint. (optional)
     * @param  \DateTime $from_date search for content changes from this time on. The maxmimum and default value is 28 days before now. Future values can be specified, but lead to an empty result. (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of content changes per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetContentChanges2Request($sku = null, $from_date = null, $page = null, $limit = null)
    {

        $resourcePath = '/v5/products/content-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($sku)) {
            $sku = ObjectSerializer::serializeCollection($sku, 'multi', true);
        }
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetMarketPlaceStatus
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\MarketPlaceStatusProductsV5
     */
    public function productsV5GetMarketPlaceStatus($sku)
    {
        list($response) = $this->productsV5GetMarketPlaceStatusWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV5GetMarketPlaceStatusWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\MarketPlaceStatusProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetMarketPlaceStatusWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV5';
        $request = $this->productsV5GetMarketPlaceStatusRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetMarketPlaceStatusAsync
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetMarketPlaceStatusAsync($sku)
    {
        return $this->productsV5GetMarketPlaceStatusAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetMarketPlaceStatusAsyncWithHttpInfo
     *
     * Read marketplace status for a single product variation
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetMarketPlaceStatusAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusProductsV5';
        $request = $this->productsV5GetMarketPlaceStatusRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetMarketPlaceStatus'
     *
     * @param  string $sku search for a marketplace status by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetMarketPlaceStatusRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5GetMarketPlaceStatus'
            );
        }

        $resourcePath = '/v5/products/{sku}/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetMarketPlaceStatusList
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV5
     */
    public function productsV5GetMarketPlaceStatusList($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        list($response) = $this->productsV5GetMarketPlaceStatusListWithHttpInfo($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);
        return $response;
    }

    /**
     * Operation productsV5GetMarketPlaceStatusListWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetMarketPlaceStatusListWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV5';
        $request = $this->productsV5GetMarketPlaceStatusListRequest($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetMarketPlaceStatusListAsync
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetMarketPlaceStatusListAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        return $this->productsV5GetMarketPlaceStatusListAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetMarketPlaceStatusListAsyncWithHttpInfo
     *
     * Read marketplace status of product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetMarketPlaceStatusListAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\MarketPlaceStatusApiResultProductsV5';
        $request = $this->productsV5GetMarketPlaceStatusListRequest($sku, $product_reference, $category, $brand_id, $from_date, $page, $limit, $market_place_status, $sort_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetMarketPlaceStatusList'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search marketplace status by the productReference value of the related product variations (optional)
     * @param  string $category search marketplace status by the category value of the related product variations (optional)
     * @param  string $brand_id search marketplace status by the brand ID value of the related product variations (optional)
     * @param  \DateTime $from_date search marketplace status for a time range starting with the given date (in ISO8601, like &#x27;2021-10-09T07:52:19.820Z&#x27; or &#x27;2021-10-09T07:52:19.820+01:00&#x27;) (optional)
     * @param  int $page page to load (optional)
     * @param  int $limit proposed limit for the number of marketplace status per response page (at most 1000) (optional)
     * @param  string[] $market_place_status only include items that match any of the provided status (optional)
     * @param  string $sort_order Define the sort order of the resulting entries. Available values are &#x27;desc&#x27; for &#x27;newest lastModified first&#x27; and &#x27;asc&#x27; for &#x27;oldest lastModified first&#x27; - default is &#x27;desc&#x27; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetMarketPlaceStatusListRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $from_date = null, $page = null, $limit = null, $market_place_status = null, $sort_order = null)
    {

        $resourcePath = '/v5/products/marketplace-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if (is_array($market_place_status)) {
            $market_place_status = ObjectSerializer::serializeCollection($market_place_status, 'multi', true);
        }
        if ($market_place_status !== null) {
            $queryParams['marketPlaceStatus'] = ObjectSerializer::toQueryValue($market_place_status, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sort-order'] = ObjectSerializer::toQueryValue($sort_order, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetPartnerProducts
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductVariationApiResultProductsV5
     */
    public function productsV5GetPartnerProducts($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetPartnerProductsWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetPartnerProductsWithHttpInfo
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductVariationApiResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetPartnerProductsWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV5';
        $request = $this->productsV5GetPartnerProductsRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetPartnerProductsAsync
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetPartnerProductsAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV5GetPartnerProductsAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetPartnerProductsAsyncWithHttpInfo
     *
     * Read product variations
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetPartnerProductsAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationApiResultProductsV5';
        $request = $this->productsV5GetPartnerProductsRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetPartnerProducts'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their brandId value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetPartnerProductsRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v5/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetProductVariation
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductVariationProductsV5
     */
    public function productsV5GetProductVariation($sku)
    {
        list($response) = $this->productsV5GetProductVariationWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV5GetProductVariationWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductVariationProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetProductVariationWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationProductsV5';
        $request = $this->productsV5GetProductVariationRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductVariationProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetProductVariationAsync
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationAsync($sku)
    {
        return $this->productsV5GetProductVariationAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetProductVariationAsyncWithHttpInfo
     *
     * Read a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductVariationProductsV5';
        $request = $this->productsV5GetProductVariationRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetProductVariation'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetProductVariationRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5GetProductVariation'
            );
        }

        $resourcePath = '/v5/products/{sku}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetProductVariationPrice
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\SkuPricingProductsV5
     */
    public function productsV5GetProductVariationPrice($sku)
    {
        list($response) = $this->productsV5GetProductVariationPriceWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV5GetProductVariationPriceWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\SkuPricingProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetProductVariationPriceWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\SkuPricingProductsV5';
        $request = $this->productsV5GetProductVariationPriceRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\SkuPricingProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetProductVariationPriceAsync
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationPriceAsync($sku)
    {
        return $this->productsV5GetProductVariationPriceAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetProductVariationPriceAsyncWithHttpInfo
     *
     * Read a single product variation price
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationPriceAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\SkuPricingProductsV5';
        $request = $this->productsV5GetProductVariationPriceRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetProductVariationPrice'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetProductVariationPriceRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5GetProductVariationPrice'
            );
        }

        $resourcePath = '/v5/products/{sku}/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetProductVariationPrices
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\PriceApiResultProductsV5
     */
    public function productsV5GetProductVariationPrices($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        list($response) = $this->productsV5GetProductVariationPricesWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit);
        return $response;
    }

    /**
     * Operation productsV5GetProductVariationPricesWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\PriceApiResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetProductVariationPricesWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\PriceApiResultProductsV5';
        $request = $this->productsV5GetProductVariationPricesRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\PriceApiResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetProductVariationPricesAsync
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationPricesAsync($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        return $this->productsV5GetProductVariationPricesAsyncWithHttpInfo($sku, $product_reference, $category, $brand_id, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetProductVariationPricesAsyncWithHttpInfo
     *
     * Read product variations prices
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetProductVariationPricesAsyncWithHttpInfo($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\PriceApiResultProductsV5';
        $request = $this->productsV5GetProductVariationPricesRequest($sku, $product_reference, $category, $brand_id, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetProductVariationPrices'
     *
     * @param  string $sku search for product variations by their sku value. Use this if your sku values contain slash (&#x27;/&#x27;) or dot (&#x27;.&#x27;) characters. (optional)
     * @param  string $product_reference search for product variations by their productReference value (optional)
     * @param  string $category search for product variations by their category value (optional)
     * @param  string $brand_id search for product variations by their ID value (optional)
     * @param  int $page (optional)
     * @param  int $limit proposed limit for the number of products per response page (at most 100) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetProductVariationPricesRequest($sku = null, $product_reference = null, $category = null, $brand_id = null, $page = null, $limit = null)
    {

        $resourcePath = '/v5/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sku !== null) {
            $queryParams['sku'] = ObjectSerializer::toQueryValue($sku, null);
        }
        // query params
        if ($product_reference !== null) {
            $queryParams['productReference'] = ObjectSerializer::toQueryValue($product_reference, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($brand_id !== null) {
            $queryParams['brandId'] = ObjectSerializer::toQueryValue($brand_id, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5GetVariationActiveStatus
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ActiveStatusProductsV5
     */
    public function productsV5GetVariationActiveStatus($sku)
    {
        list($response) = $this->productsV5GetVariationActiveStatusWithHttpInfo($sku);
        return $response;
    }

    /**
     * Operation productsV5GetVariationActiveStatusWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ActiveStatusProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5GetVariationActiveStatusWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusProductsV5';
        $request = $this->productsV5GetVariationActiveStatusRequest($sku);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ActiveStatusProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5GetVariationActiveStatusAsync
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetVariationActiveStatusAsync($sku)
    {
        return $this->productsV5GetVariationActiveStatusAsyncWithHttpInfo($sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5GetVariationActiveStatusAsyncWithHttpInfo
     *
     * Read the active status of a single product variation
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5GetVariationActiveStatusAsyncWithHttpInfo($sku)
    {
        $returnType = '\cbdesk\otto\Client\Model\ActiveStatusProductsV5';
        $request = $this->productsV5GetVariationActiveStatusRequest($sku);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5GetVariationActiveStatus'
     *
     * @param  string $sku search for a product variation by its SKU value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5GetVariationActiveStatusRequest($sku)
    {
        // verify the required parameter 'sku' is set
        if ($sku === null || (is_array($sku) && count($sku) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sku when calling productsV5GetVariationActiveStatus'
            );
        }

        $resourcePath = '/v5/products/{sku}/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sku !== null) {
            $resourcePath = str_replace(
                '{' . 'sku' . '}',
                ObjectSerializer::toPathValue($sku),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5ProgressByProcessId
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5
     */
    public function productsV5ProgressByProcessId($process_uuid)
    {
        list($response) = $this->productsV5ProgressByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV5ProgressByProcessIdWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5ProgressByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5ProgressByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5ProgressByProcessIdAsync
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5ProgressByProcessIdAsync($process_uuid)
    {
        return $this->productsV5ProgressByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5ProgressByProcessIdAsyncWithHttpInfo
     *
     * Request the results of a product data delivery
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5ProgressByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5ProgressByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5ProgressByProcessId'
     *
     * @param  string $process_uuid search for a product data delivery result by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5ProgressByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV5ProgressByProcessId'
            );
        }

        $resourcePath = '/v5/products/update-tasks/{processUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5SucceededByProcessId
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV5
     */
    public function productsV5SucceededByProcessId($process_uuid)
    {
        list($response) = $this->productsV5SucceededByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV5SucceededByProcessIdWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5SucceededByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5SucceededByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5SucceededByProcessIdAsync
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SucceededByProcessIdAsync($process_uuid)
    {
        return $this->productsV5SucceededByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5SucceededByProcessIdAsyncWithHttpInfo
     *
     * List succeeded products of a product data delivery
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5SucceededByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5SucceededByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5SucceededByProcessId'
     *
     * @param  string $process_uuid search for the succeeded products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5SucceededByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV5SucceededByProcessId'
            );
        }

        $resourcePath = '/v5/products/update-tasks/{processUuid}/succeeded';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5UnchangedByProcessId
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessResultProductsV5
     */
    public function productsV5UnchangedByProcessId($process_uuid)
    {
        list($response) = $this->productsV5UnchangedByProcessIdWithHttpInfo($process_uuid);
        return $response;
    }

    /**
     * Operation productsV5UnchangedByProcessIdWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessResultProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5UnchangedByProcessIdWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5UnchangedByProcessIdRequest($process_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5UnchangedByProcessIdAsync
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UnchangedByProcessIdAsync($process_uuid)
    {
        return $this->productsV5UnchangedByProcessIdAsyncWithHttpInfo($process_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5UnchangedByProcessIdAsyncWithHttpInfo
     *
     * List unchanged products of a product data delivery
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UnchangedByProcessIdAsyncWithHttpInfo($process_uuid)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessResultProductsV5';
        $request = $this->productsV5UnchangedByProcessIdRequest($process_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5UnchangedByProcessId'
     *
     * @param  string $process_uuid search for the unchanged products of a product data delivery identified by its processUuid. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5UnchangedByProcessIdRequest($process_uuid)
    {
        // verify the required parameter 'process_uuid' is set
        if ($process_uuid === null || (is_array($process_uuid) && count($process_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_uuid when calling productsV5UnchangedByProcessId'
            );
        }

        $resourcePath = '/v5/products/update-tasks/{processUuid}/unchanged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'processUuid' . '}',
                ObjectSerializer::toPathValue($process_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5UpdateActiveStatus
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV5 $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5
     */
    public function productsV5UpdateActiveStatus($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV5UpdateActiveStatusWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV5UpdateActiveStatusWithHttpInfo
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV5 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5UpdateActiveStatusWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5UpdateActiveStatusRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5UpdateActiveStatusAsync
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV5 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UpdateActiveStatusAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV5UpdateActiveStatusAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5UpdateActiveStatusAsyncWithHttpInfo
     *
     * Update active status
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV5 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UpdateActiveStatusAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5UpdateActiveStatusRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5UpdateActiveStatus'
     *
     * @param  \cbdesk\otto\Client\Model\ActiveStatusListRequestProductsV5 $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5UpdateActiveStatusRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v5/products/active-status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsV5UpdateProductVariationPrices
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV5[] $body body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5
     */
    public function productsV5UpdateProductVariationPrices($body = null, $x_request_timestamp = null)
    {
        list($response) = $this->productsV5UpdateProductVariationPricesWithHttpInfo($body, $x_request_timestamp);
        return $response;
    }

    /**
     * Operation productsV5UpdateProductVariationPricesWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \cbdesk\otto\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \cbdesk\otto\Client\Model\ProductProcessProgressProductsV5, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsV5UpdateProductVariationPricesWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5UpdateProductVariationPricesRequest($body, $x_request_timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsV5UpdateProductVariationPricesAsync
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UpdateProductVariationPricesAsync($body = null, $x_request_timestamp = null)
    {
        return $this->productsV5UpdateProductVariationPricesAsyncWithHttpInfo($body, $x_request_timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsV5UpdateProductVariationPricesAsyncWithHttpInfo
     *
     * Update product variation prices
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsV5UpdateProductVariationPricesAsyncWithHttpInfo($body = null, $x_request_timestamp = null)
    {
        $returnType = '\cbdesk\otto\Client\Model\ProductProcessProgressProductsV5';
        $request = $this->productsV5UpdateProductVariationPricesRequest($body, $x_request_timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsV5UpdateProductVariationPrices'
     *
     * @param  \cbdesk\otto\Client\Model\SkuPricingProductsV5[] $body (optional)
     * @param  string $x_request_timestamp Holds the optional client side update request timestamp, in ISO DateTime format (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productsV5UpdateProductVariationPricesRequest($body = null, $x_request_timestamp = null)
    {

        $resourcePath = '/v5/products/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_timestamp !== null) {
            $headerParams['X-Request-Timestamp'] = ObjectSerializer::toHeaderValue($x_request_timestamp);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
